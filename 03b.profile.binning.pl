#!/usr/bin/perl -w

=head1 NAME

  03b.profile.binning.pl - bins reads according to %GC or length

=head2 Description

    Use this script to generate list of read id's matching the binning conditions.
    These lists can then be used as inputs to cdbyank to extract the actual reads.
    This script will process only single files. When binning by paired reads, bin
    both R1 and R2 files separately, and then feed them to the following step (03c)
    if the pipeline, where the two lists will be consolidated prior to extraction
    of the reads.

=head2 Input files

    A file containing the length and %GC value (in percent, not fractions) for
    the reads to be binned, as generated by step 03a.profile.work_reads_stats;
    or by any other profiling script that may produce at least three columns of
    output:
      1. sequence/read id
      2. length
      3. gc
    The script checks for the column number of the binning parameter (either length
    or gc if it finds a row that starts with 'sequece', 'id', or 'read'; otherwise,
    it assumes %GC values are located on the third column.

=head1 USAGE

    ./03b.profile.binning.pl -f|-s -b [gc|length] -r <numeric>
    
       -s/-stats   file containing the sequence read %GC/length values
                   required unless -f/-i is given, and a statistics file
                   with '.stats' following the reads file (with or without
                   extension) exists
       -f/-file    file containing the sequence reads (optional, but required
                   if no -s <statistics_file> is given
       -i/-input   synonymous with -f
       -b/-bin     binning parameter (gc|length; default=gc)
       -m/-mode    synonymous with -b
       -r/-ranges  bin boundaries, given as a single value to bin in less-equal
                   and greater-equal bins (i.e., 0 to < r > and < r > to max),
                       or,
                   given as a comma-separated list of inter-bin boundaries. For
                   instance, a value of 30,50,70 (gc or length) will created bins
                   for values 0-30,30-50,50-70, and 70 to max.
                   (default=50)
       -h/-help    this message
       -v/-verbose progress messages printed to stderr

=head1 AUTHOR - Nicolas Pinel (ISB/LCSB - 24 April 2013)

=cut

use strict;
use Getopt::Long;
use Term::ANSIColor qw(:constants);

$Term::ANSIColor::AUTORESET = 1; # to reset color to defaul on the next print statement

my ($file,$stats,$bins,$help,$verbose);
my $bin_mode = 'gc';
GetOptions(
    'f|file|i|input=s' => \$file,
    's|stats=s'        => \$stats,
    'b|bin|m|mode=s'   => \$bin_mode,
    'r|ranges=s'       => \$bins,
    'h|help'           => \$help,
    'v|verb|verbose'   => \$verbose);

&usage() if ($help);
&loadEnv('/mnt/nfs/projects/ecosystem_biology/esb.shortcuts');

$stats = $stats ? $stats : &findStats();
print { *STDERR } GREEN BOLD qq(PASS:), RESET, qq( Will gather read information from $stats.\n) if ($verbose);

$bin_mode = $bin_mode =~ /^l/i ? 'length' : 'gc';
my $units = $bin_mode eq 'length' ? 'bp' : 'gc';

my @ranges = $bins ? split(/\,/, $bins) : (50);

if ( @ranges == 1 ) { &bin2($ranges[0]); } else { &binMany(\@ranges); }

exit;

###############
# subroutines #
###############
sub usage {
    system("perldoc $0");
    exit 0;
}

sub loadEnv {
    # loads environment shortcuts contained in the esb-specific shortcuts file
    # essential when running in passive mode in oarsub
    my $f = shift;
    my $perl_command = "perl -MData::Dumper -e 'print Dumper(\\\%ENV)';";
    my $source_line = ". $f 1>&2";
    my %tmp = %{eval('my ' . `$source_line\n$perl_command`)};
    $ENV{$_} = $tmp{$_} for (keys %tmp);
    return 0;
}

sub findStats {
    ## check to ensure the needed statistics file is available
    local *print_error = sub {
	    print { *STDERR } RED BOLD qq(ERROR:),
	    RESET, qq( Either a stats file, or a reads file with an associated reads.stats ),
	    qq(file are required. Use \-h for more information.\n);
	    exit 1;	
    };
    
    my $st;
    if (!$file) { print_error(); } else {
	$st = $file.'.stats';
	if ( -e $st ) { return $st; } else {
	    $st =~ s/\.\w+\.stats$/\.stats/;
	    if ( -e $st ) { return $st; } else { print_error(); }
	}
    }

}

sub bin2 {
    ## function to bin when only a splitting value is given (single value in option '-r')
    ## default, using gc and 50
    my $split = shift;

    my $of1 = $stats;
    my $of2 = $stats;
    $of1 =~ s/\.\w+$/\.le$split$units\.keys/;
    $of2 =~ s/\.\w+$/\.ge$split$units\.keys/;
    
    open my $o1, '>', $of1;
    open my $o2, '>', $of2;
    
    open my $in, '<', $stats;
    
    my $target = 2; ## defaults to gc on 3rd column (0-index)
    while (<$in>) {
	if ($_ =~ /^(seq|id|read)/i) {
	    my @cols = split(/\t+/);
	    for (my $i=0; $i<@cols; $i++) {
		if ($cols[$i] =~ $bin_mode) {
		    $target = $i;
		    last;
		}
	    }
	    next;
	}
	next if (/^\#/);
	chomp;
	my @fields = split(/\t/);
	if ($fields[$target] <= $split) { print $o1 "$fields[0]\n";}
	if ($fields[$target] >= $split) { print $o2 "$fields[0]\n";}
    }
    
}

sub binMany {
    ## function to bin into more than 2 bins
    my $ranges = shift;
    my %ranges = &assignBounds($ranges);
    
    foreach my $bin (sort keys %ranges) {
	my $f = $stats;
	$f =~ s/\.\w+$/\.$ranges{$bin}{'min'}\_$ranges{$bin}{'max'}\_$units\.keys/;
	open $ranges{$bin}{'fh'}, '>', $f; ## note that filehandle is stored in hash
    }
    
    my $target = 2; ## defaults to gc on 3rd column (0-index)
    open my $in, '<', $stats;
    while (<$in>) {
	if ($_ =~ /^(seq|id|read)/i) {
	    my @cols = split(/\t+/);
	    for (my $i=0; $i<@cols; $i++) {
		if ($cols[$i] =~ $bin_mode) {
		    $target = $i;
		    last;
		}
	    }
	    next;
	}
	next if (/^\#/);
	chomp;
	my @fields = split(/\t/);
	
	foreach my $bin (sort keys %ranges) {
	    if ($fields[$target] >= $ranges{$bin}{'min'}) { ## first check for value at/above min
                ## then check for last bin, or value at/below max
		if ($ranges{$bin}{'max'} =~ /\D+/ || $fields[$target] <= $ranges{$bin}{'max'}) {
		    print {$ranges{$bin}{'fh'}} "$fields[0]\n"; ## must use dereferencing parentheses with fh
		}
	    }
	}
    }    
}


sub assignBounds {
    ## determines the lower and upper bound for each bin when binning into more than 2 bins
    my $ranges = shift;

     my %hash = ();
     for (my $i=0; $i < @{$ranges}; $i++) {
	 my ($min,$max);
	 if ($$ranges[$i] =~ /:/) {
	     ($min,$max) = split(/\:/, $$ranges[$i]);
	 } else {
	     $min = $i == 0 ? 0 : $$ranges[$i-1];
	     $max = $i == @{$ranges} ? 'max' : $ranges[$i];
	 }
	 %{$hash{$i}} = ('min' => $min, 'max' => $max);
     }

    return %hash;
}

